SPEAK UP - XML CODING MANUAL - V1.0

<==========================================================================================================================>
0. What is XML?
This guide assumes you have a basic knowledge of how to read/write a XML document. If you never heard of XML, please access:
https://www.w3schools.com/xml/
and find a very nice, really easy and efficient tutorial about it. It's not even a programming language - it actually is a "bridge" between machine language and human language.

<==========================================================================================================================>
1. BASICS
Patches.xml (in the Patches folder) contains the opening sentences, while Interactions.xml (in the Defs folder) contains the reactions.
Each line of dialogue is between 2 pawns. The pawn speaking the line is called INITIATOR, while the one who is listening to the line is called RECIPIENT.
The XML writing rules for SpeakUp are based on a mix of:
- C# mechanisms already available in vanilla
- C# mechanisms coded by [JPT], either new or vanilla-based

<==========================================================================================================================>
2. BASIC TEMPLATE FOR OPENING SENTENCES

<Operation Class="PatchOperationReplace">
	<xpath>/Defs/InteractionDef[defName = "ChitChat"]/logRulesInitiator/rulesStrings</xpath>
	<value>
		<rulesStrings>
			<li>r_logentry(tag=Weather)->What a nice sunny day!</li>
			<li>r_logentry(tag=FineFood)->I had a fine meal.</li>
		</rulesStrings>
	</value>
</Operation>


Let's examine its main elements:

a) <Operation Class="PatchOperationReplace">
It's the outermost tag, enclosing our social interaction. It refers to the Patch operation, made via the HugsLib. A "Patch" is a direct replacement of a vanilla code part.

b) <xpath>/Defs/InteractionDef[defName = "ChitChat"]/logRulesInitiator/rulesStrings</xpath>
Here you can specify which vanilla code part you wish to replace. In our case, we're replacing the ChitChat vanilla section with our custom-made content. Here, we're targeting the Interactions_Social.xml vanilla file, where there is an InteractionDef whose defName is ChitChat. Specifically, we're replacing whatever is included in the <rulesString> section.

If you wish, you can replace other parts of Interactions_Social.xml vanilla file (or other similar files) - you just have to specify the right path.

c) <value> and <rulesStrings>
Notice you have to specifiy <rulesStrings> both in the <xpath> and here.
Also, <rulesStrings> encloses all the <li>s, i.e. all the lines of dialogue.

d) <li>r_logentry(tag=Weather)->What a nice sunny day!</li>
This is one of the actual lines of dialogue. Each line must:
- start with <li> and end with </li>
- have "r_logentry->" just after <li>
- IMPORTANT: if you write "r_logentry-" and forget the ">", the game will crash. Typos in general might be fatal so it's very important to make all the efforts to avoid them.
In this simple example, the program will randomly select one of the two lines and use it to start a dialogue.

d1) (tag=Weather)
This is a key mechanism. It means the code will look up the Interactions.xml file to search for an InteractionDef whose <defName> element matches "Weather". If it finds one, then it will be used as a reaction to our present social interaction. So the first line will lead to an answer about weather, whereas the second line will lead to an answer about food.

IMPORTANT: you cannot use any space between the brackets. Resist the temptation to write (tag = Weather), or there will be bugs or worse.
Notice SpeakUp already contains basic patched content, so you might just expand the content inside the available PatchOperations by adding extra <li> lines - but you could also include new patch operations. I believe it's safer to have always distinct patched section - for instance, I believe it's certain doom if you include two ChitChat patches in the same XML document, targeting the same vanilla sections.

<==========================================================================================================================>
3. BASIC TEMPLATE FOR REACTIONS

<InteractionDef ParentName="SpeakUpReply">
	<defName>Weather</defName>
	<label>react - weather</label>
	<logRulesInitiator>
		<rulesStrings>
			<li>r_logentry->I just love sunny days!</li>
			<li>r_logentry->Yes, it's perfect for a picnic!</li>
			<li>r_logentry->Nice weather is a blessing for all of us!</li>
		</rulesStrings>
	</logRulesInitiator>
</InteractionDef>


Let's examine its main elements:
a) <InteractionDef ParentName="SpeakUpReply">
It's the outermost tag, enclosing our social interaction.

b) <defName>Weather</defName>
If the Patches.xml file contains a line with a matching tag (i.e. "r_logentry(tag=Weather)->" in this case), this social interaction will be called and used.

c) <label>react - weather</label>
This is used for debugging/internal management mainly. When you debug, you will see "react - weather" in the possible interactions list.

d) <rulesStrings>
It encloses all the <li>s, i.e. all the lines of dialogue.

e) <li>r_logentry->I just love sunny days!</li>
This is one of the lines of dialogue. Each line must:
- start with <li> and end with </li>
- have "r_logentry->" just after <li>
- IMPORTANT: if you write "r_logentry-" and forget the ">", the game will crash. Typos in general might be fatal so it's very important to make all the efforts to avoid them.

In this simple example, the reacting pawn will randomly use one of the three sentences listed here. 

In our examples above, Patches.xml contains a line with the (tag=Weather) call. Since our reaction here contains <defName>Weather</defName>, it will be actually be chosen and launched as reaction. So, we can expect this dialogue to occur:

Pawn1: What a nice sunny day!
Pawn2: Yes, it's perfect for a picnic!

Or also:
Pawn1: What a nice sunny day!
Pawn2: I just love sunny days!

Of course, if our Interactions.xml contained another InteractionDef containing <defName>FineFood</defName>, the dialogue would have been about food and not about weather.

You can insert as many <li>s as you wish. You might want to organize them with comments, such as "<!-- = MyDialogue = -->".

<==========================================================================================================================>
4. CONDITIONED LINES
Consider this example:
<li>r_logentry->What a nice sunny day!</li>
This line will be spoken no matter what. There is no condition for it. It would be spoken even if it rained.
Yet, we actually need it to be spoken only if the weather is clear.

How can we do this?
We do it like this:

<li>r_logentry(WEATHER==clear)->What a nice sunny day!</li>

Also, we might want to condition it to the pawn's mood, as a furious pawn would never say those words. 
So we can code:
<li>r_logentry(WEATHER==clear,INITIATOR_mood>=25)->What a nice sunny day!</li>

Finally, if this line needs a reaction, we must include a "tag" condition, as shown earlier. So we should code:
<li>r_logentry(WEATHER==clear,INITIATOR_mood>=25,tag=SunnyDay)->What a nice sunny day!</li>

Here's another example:
<li>r_logentry(INITIATOR_thought=AteFineMeal,tag=FineMeal)->I had a fine meal.</li>

And another:
<li>r_logentry(RECIPIENT_thought=AteFineMeal,tag=RecipientFineMeal)->You had a fine meal.</li>

IMPORTANT: the conditioning section between brackets must NOT contain any space, except for spaces in the parameters (if any).
Good example: (INITIATOR_trait==annoying voice)
Bad example: (INITIATOR_trait==annoying voice, DAYPERIOD=morning, WEATHER=clear)

We can use the following operators:
a) ==
Example: WEATHER==clear

b) > or >=
Example: INITIATOR_mood>=25

c) &lt; or &lt;=
This is more tricky. It actually represents "<" and "<=". But since using "<" would stop XML from working, we use "&lt;" instead.

d) !=
This one is tricky too. It means "NOT", but it can be used only for specific parameters - generally those who have just one possible value at a time.

Good example:
INITIATOR_gender!=Male --> This works, because a pawn has only one gender at any time.

Bad example:
INITIATOR_trait!=ascetic --> This doesn't work, because a pawn can have multiple traits.

We can fix this shortcoming by using the priorities mechanism, which will be shown in this document later in Chapter 9.

As far as I know there is no "OR" operator, but again we can bypass this by using Wildcards, which will be shown in the next chapter.

As for what you can use as parameters, I'll try and offer a somewhat complete list in the final Appendix. For now, it's useful to know that all pawn-related parameters start with "INITIATOR_" or "RECIPIENT_".

<==========================================================================================================================>
5. WILDCARDS
Let's consider:
<li>r_logentry(WEATHER==clear,INITIATOR_mood>=25,tag=WeatherGoodMood)->What a nice sunny day!</li>
Of course we'd like to give more variety and let the pawns speak several sentences in the same situation, to avoid frequent repetitions.
So, we could add this code:
<li>r_logentry(WEATHER==clear,INITIATOR_mood>=25,tag=WeatherGoodMood)->What a fine sunny weather!</li>
<li>r_logentry(WEATHER==clear,INITIATOR_mood>=25,tag=WeatherGoodMood)->What a pleasant sun we have today!</li>

It gets quite messy and repetitive and typos can occur more easily. Wildcards help to reduce this problem with this strategy:

<li>r_logentry(WEATHER==clear,INITIATOR_mood>=25,tag=WeatherGoodMood)->[weather_clear_good_mood]</li>
<li>weather_clear_good_mood->What a nice sunny day!</li>
<li>weather_clear_good_mood->What a fine sunny weather!</li>
<li>weather_clear_good_mood->What a pleasant sun we have today!</li>

Whatever is written between the [] brackets is called a Wildcard and - when read by the code - it will be expanded in one of the name-matching options listed below.

This structure lets you avoid repetitions (and related typos) and have a clearer view of when the dialogue line is used.
If you plan to have more depth and detail, I believe the best practice is a per-condition wildcard, coded into a commented and indented structure:

<!-- CLEAR WEATHER -->
<li>r_logentry(WEATHER==clear,tag=WeatherClear)->[weather_clear]</li>
weather_clear->We have a clear weather today.
	<!-- GOOD MOOD -->
	<li>weather_clear(INITIATOR_mood>=25,tag=WeatherClear_GoodMood)->[weather_clear_good_mood]</li>
	<li>weather_clear_good_mood->What a nice sunny day!</li>
	<li>weather_clear_good_mood->What a fine sunny weather!</li>
	<li>weather_clear_good_mood->What a pleasant sun we have today!</li>

So what we do here is create a separate "paragraph" for managing clear weather and then a "sub-paragraph" managing the specific case of clear weather AND pawns having good mood.
This is a good practice only if you plan to write complex dialogues - otherwise it's much better to use the simpler line, without wildcards.

As you can see, wildcards are recursively managed (i.e. you can have wildcards embedded in wildcards) and are hugely useful to organize your XML. But they come with several rigid rules we must keep track of.

<==========================================================================================================================>
6. WILDCARDS RULES
a) Wildcards cannot have upper case letters. Based on what I can understand, the presence of at least one upper case letter tells the program to expand the wildcard using special resources outside of the XML document, in a specific Rimworld path. You can use underscore and all, but never an upper case symbol. For instance, I found out that [Animals] wildcard returns a random animal from a .txt resource in one of the Rimworld game subpaths.

b) Wildcards are InteractionDef-related. This means that if you use a "[food]" wildcard in one InteractionDef, it will be used in the whole InteractionDef (but not in others). So if your InteractionDef is very complex and rich (with many sub-sections), you must consider naming your wildcards in a more detailed way, to avoid ambiguities. 
For instance, you can define a "[food]" wildcard in a ChitChat interaction and then a wildcard with the very same name in a DeepTalk interaction - this won't be a problem, as we're speaking of two distinct interactions.
But if you want to use a "[food]" wildcard in two sub-sections of the same ChitChat interaction, you must name wildcards with a per-section name, e.g. "[food_1]" and "[food_2]".

c) Whenever you create a wildcard, it is as if you created a new path to a new content. This content must lead to somewhere, or the code will generate an error.
Consider this example:
<li>r_logentry->[my_wildcard]</li>
<li>my_wildcard(INITIATOR_opinion>=0)->Hello there!</li>
<li>my_wildcard(INITIATOR_opinion>=0)->Hi, friend!</li>

This code works only if the initiator pawn has a positive or zero opinion of the recipient pawn. Were this negative instead, the code would lead nowhere and generate an error. Let's see why:
- the code detects and expands the [my_wildcard] wildcard
- it tries to select the "Hello there!" line by checking if INITIATOR_opinion>=0, but it fails to do so
- it tries to select the "Hi, friend!" line by checking if INITIATOR_opinion>=0, but it fails to do so as well
- since the [my_wildcard] wildcard gave no viable result (none of the lines matched the conditions), the code will generate an error

We can avoid this kind of situation by guaranteeing that each wildcard always leads to somewhere valid. And I can think of two ways to do this.
The first one is including a set of conditions covering all the possibilities. As in the following example:
<li>r_logentry->[my_wildcard]</li>
<li>my_wildcard(INITIATOR_opinion>=0)->Hello there!</li>
<li>my_wildcard(INITIATOR_opinion&lt;0)->Get out of my way!</li>

Here you can see I'm using the initiator pawn's opinion as a criteria, but I'm featuring all the possible cases: an opinion is a value ranging from -100 to 100 and so once I cover the ">=0" and the "<0" case, I've covered all the possibilities. Moreover, a pawn always has an opinion about another pawn (as far as I know), so this code will always produce a result.
This first method is fine, but it is not fully risk-free - for instance, there might be some unknown peculiar situation where the "opinion" value is unspecified - which would lead to an error. I really never encountered such a case, but... who knows?

So, there is a second risk-free option:
<li>r_logentry->[my_wildcard]</li>
<li>my_wildcard(INITIATOR_opinion>=0)->Hello there!</li>
<li>my_wildcard(INITIATOR_opinion&lt;0)->Get out of my way!</li>
<li>my_wildcard->Hi.</li>

The third line is unconditioned, so it is like a default if other lines fail to be selected. Please try to guarantee a default option at all times. If you really are unsure about a default option, you can still code this:
<li>r_logentry->[my_wildcard]</li>
<li>my_wildcard(INITIATOR_opinion>=0)->Hello there!</li>
<li>my_wildcard(INITIATOR_opinion&lt;0)->Get out of my way!</li>
<li>my_wildcard-></li>

The third line leads to an empty (yet valid) sentence, which is fine code-wise - but it could be strange game-wise, since it's as if a pawn tries to speak something but nothing comes out. This is even risky for debugging, because an empty sentence cannot be easily detected while playing. If you wish, especially in debugging stage, you can code "<li>my_wildcard->DEBUG</li>" for the 3rd line.

<==========================================================================================================================>
7. WILDCARDS USE TO SIMULATE AN "OR" LOGICAL OPERATOR
Consider this example:
<li>r_logentry(INITIATOR_trait==sanguine)->The world is a wonderful place!</li>
<li>r_logentry(INITIATOR_trait==optimist)->The world is a wonderful place!</li>

This coding is perfectly valid, although repetitive and clumsy (especially if you consider writing several lines for the sanguine and optimist cases, not just one as in this example). 

It'd be wonderful to have something like this:
<li>r_logentry(INITIATOR_trait==sanguine||INITIATOR_trait==optimist)->The world is a wonderful place!</li>

That is, it'd be wonderful to have an OR explicit operator (here imagined by me as "||"). But, as far as I know, there is no such thing available, unfortunately.

But wildcards come to our help, like this:
<li>r_logentry(INITIATOR_trait=sanguine)->[optimistic_traits]</li>
<li>r_logentry(INITIATOR_trait=optimist)->[optimistic_traits]</li>
<li>optimistic_traits->The world is a wonderful place!</li>

This snippet works as an OR operator. 
Moreover, it saves time and helps consistency: suppose later on you decide that "The world is a wonderful place!" sentence needs to be changed, you can change it just once in the 3rd line instead of changing it twice in the previous repetitive example. Also: since you type less, you are less likely to end up with a typo and create inconsistencies.

<==========================================================================================================================>
8. WILDCARDS USED FOR MORE VARIETY
Consider this example:
<li>r_logentry(INITIATOR_animals_passion==Major)->I just love bunnies!</li>

If you just use this, it gets repetitive very quickly. We need some variety. So we might code:
<li>r_logentry(INITIATOR_animals_passion==Major)->I just love bunnies!</li>
<li>r_logentry(INITIATOR_animals_passion==Major)->I just love kitties!</li>
<li>r_logentry(INITIATOR_animals_passion==Major)->I just love puppies!</li>
<li>r_logentry(INITIATOR_animals_passion==Major)->I just love parrots!</li>
<li>r_logentry(INITIATOR_animals_passion==Major)->I just love chickens!</li>
<li>r_logentry(INITIATOR_animals_passion==Major)->I just love ponies!</li>

As you can see, most of this snippet is repetitive. Can we avoid this? Yes - again, wildcards are our friends:
<li>r_logentry(INITIATOR_animals_passion==Major)->I just love [colony_animals]!</li>
<li>colony_animals->bunnies</li>
<li>colony_animals->kitties</li>
<li>colony_animals->puppies</li>
<li>colony_animals->parrots</li>
<li>colony_animals->chickens</li>
<li>colony_animals->ponies</li>

Again, as in the previous chapter, we save time and guarantee consistency if we wish to alter the main sentence. Also, we can easily update the animals list as we wish.

We can do this, theoretically, with all the parts of the sentence - but then, we should guarantee all the possible options work well with all the other wildcards. Risky, but it hugely pays off if you can make it work!
Here's a shortened, commented, heavily wildcard reliant example:

<li>r_logentry(INITIATOR_animals_passion==Major)->[passion_major_animals]</li>
<li>passion_major_animals-> [love] [colony_animals]! [comment]</li>
<!--LOVE-->
<li>love->I just love</li>
<li>love->I simply adore</li>
<li>love->I really fancy</li>
<!--ANIMALS-->
<li>colony_animals->bunnies</li>
[... insert here the animals list as in the previous example ...]
<!--COMMENT-->
<li>comment->I find them so cute!</li>
<li>comment->I think they're great to have around.</li>
<li>comment->Having them around makes me smile.</li>
<li>comment->I wish I could hug one right now!</li>
<li>comment->I'll try and buy one when the next caravan passes by.</li>
<li>comment->I'll try and tame one for me.</li>

For sufficiently long options lists, generating the same sentence twice will be quite difficult - and this is very desirable.

Moreover, you can use all the aforementioned tricks. For instance, do you remember wildcards are recursive? So we can code:
<li>love->I [love_adverb] [love_verb]</li>
<li>love_adverb->just</li>
<li>love_adverb->simply</li>
<li>love_adverb->really</li>
<li>love_adverb->do</li>
<li>love_adverb-></li>
<li>love_verb->love</li>
<li>love_verb->adore</li>
<li>love_verb->like very much</li>
<li>love_verb->think the world of</li>

Sidenote: the "love_adverb->" empty option is on purpose. We might simply want an alternative where no adverb is used.

Also, we can condition wildcards:
<!--COMMENT-->
<li>comment->I find them so cute!</li>
<li>comment->I think they're great to have around.</li>
<li>comment->Having them around makes me smile.</li>
<li>comment->I wish I could hug one right now!</li>
<li>comment(INITIATOR_social_level>=5)->I'll try and buy one when the next caravan passes by.</li>
<li>comment(INITIATOR_animals_level>=5)->I'll try and tame one for me.</li>

And for the "love_verb" and "love_adverb" sections (if my knowledge of spoken English is right):
<li>love_verb(INITIATOR_intellectual_level>=5)->think the world of</li>
<li>love_adverb(INITIATOR_intellectual_level>=5)->do</li>

This is to portrait a more "posh" (?) speaker, imagining a more intellectual pawn would speak in a more fancy way (but, you might disagree and use the Social skill instead for this, as you wish).

In the end, by providing good alternatives, we can have a huge variety of sentences, consistent with the situation at hand. Some of the many possible outcomes are:
- I just adore ponies! I find them so cute!
- I really love chickens! I wish I could hug one right now!
- I simply adore bunnies! Having them around makes me smile.
- I love parrots! I think they're great to have around.

For a pawn with high Intellectual and Social skills, we could have:
- I think the world of kitties! I'll try and buy one when the next caravan passes by.

As you can see, we have some nice variety here, by using a short list of options. Imagine what happens, then, if you write a long list!
Of course the more you risk it with wildcards, the more you can end up with weird sentences (who would really want to hug a chicken!?) - but then, you can tailor XML so as to exclude these strange sentences from the possible outcomes. 
For instance, you could exclude chickens from this example and write a chicken-only XML section, where pawns can express all their love for chickens - but without any awkward hugging.

<==========================================================================================================================>
9. PRIORITIES AND RANDOM LINE SELECTION BASIC MECHANISM
Let's suppose we have these lines in the same InteractionDef:
<li>r_logentry->I hate mechanoids!</li>
<li>r_logentry->I think I know what technical failure doomed our ship.</li>
<li>r_logentry->I think cooperation is the key for success here!</li>
<li>r_logentry->I really enjoy waking up early in the morning.</li>

The code will evaluate them one by one to check if they are valid sentences or not. In our case, since none of them has any conditions, all of them are considered valid.
So we have 4 options, but only one will be selected in the end - the one that the pawn will actually speak. How is this choice made?
In the case above, the choice is completely random: each option has 1 in 4 chances to be chosen.

How can I change this? Well, first of all you can condition your lines. Consider this code:
<li>r_logentry->I hate mechanoids!</li>
<li>r_logentry(INITIATOR_intellectual_level>=10)->I think I know what technical failure doomed our ship.</li>
<li>r_logentry->I think cooperation is the key for success here!</li>
<li>r_logentry(INITIATOR_trait==quick sleeper)->I really enjoy waking up early in the morning.</li>

As earlier, each line is evaluated - but this time some of them might not satisfy the conditions. Let's suppose our initiator pawn has a "quick sleeper" trait, but has a zero intellectual skill level.
If this is the case, the 2nd line will be ignored. The code will just consider lines 1, 3 and 4. After this initial check, it randomly choses between these 3 options - and the chosen one is spoken out.

So a highly intellectual, quick sleeper pawn could speak any one of those - while a highly intellectual pawn with no quick sleeper trait would only speak one of the first three sentences. 

Let's suppose now that for some reason this pawn - if capable - should always comment "I think I know what technical failure doomed our ship", avoiding other lines.
To implement this, we can rely on the "priority" mechanism:
<li>r_logentry->I hate mechanoids!</li>
<li>r_logentry(INITIATOR_intellectual_level>=10,priority=1)->I think I know what technical failure doomed our ship.</li>
<li>r_logentry->I think cooperation is the key for success here!</li>
<li>r_logentry(INITIATOR_trait==quick sleeper)->I really enjoy waking up early in the morning.</li>

Observe the "priority=1" part in the second line. In this case, the code evaluates all the lines one by one as usual, but starting from the highest priority line(s). In this case, only one option has the highest priority - the one with the "priority=1" part. So, if valid, it will be certainly selected and spoken out - as it's the only option available.
But if the initiator's intellectual level is not high enough, then the "priority=1" sentence will be discarded, and the code will analyze the other "surviving" three sentences (namely 1, 3 and 4). Supposing our pawn is not a quick sleeper, then the possible selection narrows to only options 1 and 3 - and, finally, each one of them will have a 50% chance of being selected and spoken out.
 
So the "priority" mechanism is just that: it allows you to give priority to certain sentences, so that they can be evaluated before others. If their condition(s) are not met, then the code evaluates the other sentences, all in priority order. You can have, for instance:
<li>r_logentry->I hate mechanoids!</li>
<li>r_logentry(INITIATOR_intellectual_level>=10,priority=1)->I think I know what technical failure doomed our ship.</li>
<li>r_logentry->I think cooperation is the key for success here!</li>
<li>r_logentry(INITIATOR_trait==quick sleeper,priority=2)->I really enjoy waking up early in the morning.</li>

In this case, the quick sleeper trait is evaluated first (priority=2). If this check fails, the Intellectual skill level is evaluated (priority=1). And if this too fails, then only the two surviving unconditioned sentences will be considered and the final spoken sentence will be randomly chosen between them.

Although these examples might seem a bit too specific (or even pointless, maybe?), there is a case where priorities are obviously useful: the NOT operator.

<==========================================================================================================================>
10. "NOT" OPERATOR BY USING PRIORITY
Suppose you want every pawn - except undergrounders - to say "I love being outside in the sun!".
The first code writing attempt would be of course:
<li>r_logentry(INITIATOR_trait!=undergrounder)->I love being outside in the sun!</li>

Unfortunately, the basic "!=" (i.e. "NOT") operator won't work. So we need an alternative. Here it is:
<li>r_logentry(INITIATOR_trait==undergrounder,priority=1)->I'm not comfortable outdoors.</li>
<li>r_logentry->I love being outside in the sun!</li>

The code checks first if the pawn is an undergrounder. If this is not the case, then it will consider the second line. And since this second line is unconditioned, it will be used always.

So, this snippet does what we wanted: if the pawn is not an undergrounder, the spoken sentence will always be "I love being outside in the sun!".
Of course we are forced to create a proper sentence when the pawn is, in fact, an undergrounder. It's an unwanted setback, I admit. If this is a problem, you could use a blank sentence:
<li>r_logentry(INITIATOR_trait==undergrounder,priority=1)-></li>

Not ideal, but it's what we have for now.

<==========================================================================================================================>
11. PROBABILITIES
I have little information and experience for this mechanism, but I'll show here what I know.
Let's consider this again:

<li>r_logentry->I hate mechanoids!</li>
<li>r_logentry->I think I know what technical failure doomed our ship.</li>
<li>r_logentry->I think cooperation is the key for success here!</li>
<li>r_logentry->I really enjoy waking up early in the morning.</li>

As you know by now, each line has the same chance of being selected, since they are all unconditioned. 
Of course, you could alter this by using conditions. 
But what if you just want to directly favor (or hinder) chances for a specific line? You can do like this:

<li>r_logentry(p=0.5)->I hate mechanoids!</li>
<li>r_logentry(p=2)->I think I know what technical failure doomed our ship.</li>
<li>r_logentry->I think cooperation is the key for success here!</li>
<li>r_logentry->I really enjoy waking up early in the morning.</li>

This way, the first line will be selected with half of the default chance, whereas the second line will be selected with double chance. 
In other words, it is as if the second were written twice, so it has double chance of being selected.
As for the first line, it's trickier: you must make some abstraction and imagine it as if it were written one half times.

Wrapping it up in an easy and generic way: higher "p" means higher chances of being selected.

I understand that the default is "p=1" and all other numbers are relative to this.

You may want to use this mechanism so that a more "pressing" or "commonplace" sentence has a higher probability of showing up. A case of extreme emergency, for instance, needs to be spoken more often than a normal sentence - so we could use the "p" mechanism for it. 
I was thinking myself of giving higher priority to situations like extreme hunger, but I decided not using this mechanism yet - as I'm already tackling with a lot of features and possibilites already. 

If you have any suggestions or ideas about how to better use this mechanism, please let me know.

<==========================================================================================================================>
12. APPENDIX-PARAMETERS
